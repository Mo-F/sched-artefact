/* --- Generated by genom 2.99.30. Do not edit -------------------------- */




/* This UPPAAL sepcification is automatically generated. Mohammed Foughali, May 2019 */

   


/* ports */

const int nports:= 4;
bool ports[nports]:= { false, false, false, false};



/* scheduling channels */

urgent chan insert;
broadcast chan cnt;
urgent broadcast chan up, en;

/* priority */

chan priority default < up < insert;

/* scheduling constants & global variables */

int nc := 4;
int rel_count := 0;
int len:= 0;
const int size_sched := 5;
int w[size_sched] := {-2,-2,-2,-2,-2};

int p[size_sched] := {-2,-2,-2,-2,-2};

int T[size_sched] := {-2,-2,-2,-2,-2};

const int period[size_sched] := {50, 50, 200, 50, 50};


/* urgency */

urgent chan exe;

/* channels, variables and functions (robloco) */
/* channels */

urgent chan end_recv_robloco, recv_robloco, recv_urg_robloco, shuttimer_odo_robloco, begin_odo_robloco, inter_odo_robloco, shuttimer_track_robloco, begin_track_robloco, inter_track_robloco;

	
broadcast chan end_spawn_track_robloco, end_spawn_odo_robloco;

//chan priority default < up < insert;



/* constants & global variables */
bool shut_robloco:= false;

bool sched_robloco:= false;
bool lock_odo_robloco:= true;
bool finished_odo_robloco:= false;
bool tick_odo_robloco:= false;
bool lock_track_robloco:= true;
bool finished_track_robloco:= false;
bool tick_track_robloco:= false;
/* services IDs */
/* attributes, activities & functions */
const int InitPosPort_robloco:= 0;
const int TrackOdoStart_robloco:= 1;
const int TrackSpeedStart_robloco:= 2;
const int nserv_robloco:= 3;
const int width_robloco:= 3;
const int size_robloco:= width_robloco*2+1;
// the abort request is a negative "i" number that refers to interrupting the element whose index is i+size-1 
const int kill_robloco:= -1*size_robloco;

/* services with validate */

/* none (urgent reaction of CT with no request in the mbox) */
const int none_robloco:= kill_robloco -1;

/* status */
// this choice is deleberate to ease manipulating interruptions
const int RUN_robloco:= 0;
const int WAIT_robloco:= 1;
const int STOP_robloco:= 2;
const int ETHER_robloco:= 3; 
const int VOID_robloco:= 4;

/* activities array */
/* structure */ 
typedef struct {int [-1,width_robloco-1] name; int [1,2] inst; int [RUN_robloco,VOID_robloco] status;} cell_robloco;
/* initialisation */
cell_robloco tab_robloco[size_robloco] := { {InitPosPort_robloco,1,VOID_robloco}, {InitPosPort_robloco,2,VOID_robloco}, {TrackOdoStart_robloco,1,VOID_robloco}, {TrackOdoStart_robloco,2,VOID_robloco}, {TrackSpeedStart_robloco,1,VOID_robloco}, {TrackSpeedStart_robloco,2,VOID_robloco}, {-1,1,VOID_robloco} }; 
int [none_robloco,nserv_robloco-1] req_robloco:= kill_robloco;


cell_robloco turn_odo_robloco:={-1,1,VOID_robloco};

cell_robloco turn_track_robloco:={-1,1,VOID_robloco};



/* mutual exclusion array */

const int length_mut_robloco:= 4;
bool mutex_robloco[length_mut_robloco]:= {false, false, false, false};
/* functions */

/* abort and kill effect */
	
	
void interrupt_cntrl_robloco (int[none_robloco,-1] i, cell_robloco &tab[size_robloco], bool &shut) {
int[0,size_robloco-1] j;
if (i==none_robloco) {return;}
if (i!=kill_robloco) {
            if (tab[i+size_robloco-1].status<STOP_robloco) {tab[i+size_robloco-1].status += STOP_robloco;}
						return;}
for (j:=0; j<size_robloco-1; j++) {
                    if (tab[j].status<STOP_robloco) {tab[j].status += STOP_robloco;}}
shut := true;
}

/* clear and launch */
void launch_serv_robloco (cell_robloco &tab[size_robloco]) {
int i,j;
bool launch:= true;
for (i:=0; i<size_robloco-1; i++) {
            if (tab[i].status==ETHER_robloco) {tab[i].status:=VOID_robloco;}//final replies
}
for (i:=0; i<size_robloco-1; i++) {
    if (tab[i].status==WAIT_robloco) {		
        if (tab[i].name==InitPosPort_robloco) {tab[i].status:=RUN_robloco;}
        else {
   if (tab[i].name==TrackOdoStart_robloco) {
   for (j:= 0; (j<size_robloco-1 && launch); j++) {
                if (j!=i && (tab[j].name == TrackOdoStart_robloco) && tab[j].status!=VOID_robloco) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_robloco;}
               else {launch:= true;}}
       
	
   else
   if (tab[i].name==TrackSpeedStart_robloco) {
   for (j:= 0; (j<size_robloco-1 && launch); j++) {
                if (j!=i && (tab[j].name == TrackSpeedStart_robloco) && tab[j].status!=VOID_robloco) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_robloco;}
               else {launch:= true;}}
       }
}
}}                    
/* interrupt incompatible instances */
void manage_intterupt_robloco (int[0,nserv_robloco-1] s, int[0,size_robloco-2] i, cell_robloco &tab[size_robloco]) {
int[0,size_robloco-1] j;	
	if (s == TrackOdoStart_robloco) {
		for (j:= 0; j<size_robloco-1; j++) {
		if (j != i && (tab[j].name == TrackOdoStart_robloco) && tab[j].status<2) {tab[j].status += 2;}}
				return;}	
	if (s == TrackSpeedStart_robloco) {
		for (j:= 0; j<size_robloco-1; j++) {
		if (j != i && (tab[j].name == TrackSpeedStart_robloco) && tab[j].status<2) {tab[j].status += 2;}}
				return;}
}

/* update status of terminated services */
void update_robloco (bool &finished, int[0,size_robloco-2] i, cell_robloco &tab[size_robloco]) {
if (finished) {finished:= false;
                tab[i].status:= ETHER_robloco;}
}

/* signal the end of at least an activity */
bool sched_cntrl_robloco (cell_robloco tab[size_robloco]) {
int[0,size_robloco-1] i;
for (i:=0; i<size_robloco-1; i++) {
                       if (tab[i].status == ETHER_robloco) {return true;}}
return false;}

/* look for a slot and interrupt if necesary */
void slot_search_robloco (int[0,width_robloco-1] a, cell_robloco &tab[size_robloco]) {
int[0,size_robloco-1] i:= 0;
while (tab[i].name != a) {i:= i+1;}
while (tab[i].name == a) {if (tab[i].status == VOID_robloco)
                           {tab[i].status := WAIT_robloco;
                            manage_intterupt_robloco(a, i, tab);
                            return;}
                            i:= i+1;}
return;}

/* look for the next instance to execute */
int next_robloco (int[0,size_robloco-1] i, cell_robloco tab[size_robloco], int[0,size_robloco-1] stop_point) {
while (i < stop_point) {
 if (tab[i].status == RUN_robloco || tab[i].status == STOP_robloco) {return i;}
 i:= i+1;}
return size_robloco-1;}

/* shutdown */
bool off_signal_robloco (cell_robloco tab[size_robloco]) {
int[0,size_robloco-1] j;
for (j:= 0; j<size_robloco-1; j++) {
    if (tab[j].status != VOID_robloco && tab[j].status != ETHER_robloco) {return false;}}
return true;}

/* channels, variables and functions (robmotion) */
/* channels */

urgent chan end_recv_robmotion, recv_robmotion, recv_urg_robmotion, shuttimer_plan_robmotion, begin_plan_robmotion, inter_plan_robmotion;

	
broadcast chan end_spawn_plan_robmotion;

//chan priority default < up < insert;



/* constants & global variables */
bool shut_robmotion:= false;

bool sched_robmotion:= false;
bool lock_plan_robmotion:= true;
bool finished_plan_robmotion:= false;
bool tick_plan_robmotion:= false;
/* services IDs */
/* attributes, activities & functions */
const int GotoPosition_robmotion:= 0;
const int nserv_robmotion:= 1;
const int width_robmotion:= 1;
const int size_robmotion:= width_robmotion*2+1;
// the abort request is a negative "i" number that refers to interrupting the element whose index is i+size-1 
const int kill_robmotion:= -1*size_robmotion;

/* services with validate */

/* none (urgent reaction of CT with no request in the mbox) */
const int none_robmotion:= kill_robmotion -1;

/* status */
// this choice is deleberate to ease manipulating interruptions
const int RUN_robmotion:= 0;
const int WAIT_robmotion:= 1;
const int STOP_robmotion:= 2;
const int ETHER_robmotion:= 3; 
const int VOID_robmotion:= 4;

/* activities array */
/* structure */ 
typedef struct {int [-1,width_robmotion-1] name; int [1,2] inst; int [RUN_robmotion,VOID_robmotion] status;} cell_robmotion;
/* initialisation */
cell_robmotion tab_robmotion[size_robmotion] := { {GotoPosition_robmotion,1,VOID_robmotion}, {GotoPosition_robmotion,2,VOID_robmotion}, {-1,1,VOID_robmotion} }; 
int [none_robmotion,nserv_robmotion-1] req_robmotion:= kill_robmotion;


cell_robmotion turn_plan_robmotion:={-1,1,VOID_robmotion};


/* functions */

/* abort and kill effect */
	
	
void interrupt_cntrl_robmotion (int[none_robmotion,-1] i, cell_robmotion &tab[size_robmotion], bool &shut) {
int[0,size_robmotion-1] j;
if (i==none_robmotion) {return;}
if (i!=kill_robmotion) {
            if (tab[i+size_robmotion-1].status<STOP_robmotion) {tab[i+size_robmotion-1].status += STOP_robmotion;}
						return;}
for (j:=0; j<size_robmotion-1; j++) {
                    if (tab[j].status<STOP_robmotion) {tab[j].status += STOP_robmotion;}}
shut := true;
}

/* clear and launch */
void launch_serv_robmotion (cell_robmotion &tab[size_robmotion]) {
int i,j;
bool launch:= true;
for (i:=0; i<size_robmotion-1; i++) {
            if (tab[i].status==ETHER_robmotion) {tab[i].status:=VOID_robmotion;}//final replies
}
for (i:=0; i<size_robmotion-1; i++) {
    if (tab[i].status==WAIT_robmotion) {
   if (tab[i].name==GotoPosition_robmotion) {
   for (j:= 0; (j<size_robmotion-1 && launch); j++) {
                if (j!=i && (tab[j].name == GotoPosition_robmotion) && tab[j].status!=VOID_robmotion) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_robmotion;}
               else {launch:= true;}}
       }
}
}                    
/* interrupt incompatible instances */
void manage_intterupt_robmotion (int[0,nserv_robmotion-1] s, int[0,size_robmotion-2] i, cell_robmotion &tab[size_robmotion]) {
int[0,size_robmotion-1] j;	
	if (s == GotoPosition_robmotion) {
		for (j:= 0; j<size_robmotion-1; j++) {
		if (j != i && (tab[j].name == GotoPosition_robmotion) && tab[j].status<2) {tab[j].status += 2;}}
				return;}
}

/* update status of terminated services */
void update_robmotion (bool &finished, int[0,size_robmotion-2] i, cell_robmotion &tab[size_robmotion]) {
if (finished) {finished:= false;
                tab[i].status:= ETHER_robmotion;}
}

/* signal the end of at least an activity */
bool sched_cntrl_robmotion (cell_robmotion tab[size_robmotion]) {
int[0,size_robmotion-1] i;
for (i:=0; i<size_robmotion-1; i++) {
                       if (tab[i].status == ETHER_robmotion) {return true;}}
return false;}

/* look for a slot and interrupt if necesary */
void slot_search_robmotion (int[0,width_robmotion-1] a, cell_robmotion &tab[size_robmotion]) {
int[0,size_robmotion-1] i:= 0;
while (tab[i].name != a) {i:= i+1;}
while (tab[i].name == a) {if (tab[i].status == VOID_robmotion)
                           {tab[i].status := WAIT_robmotion;
                            manage_intterupt_robmotion(a, i, tab);
                            return;}
                            i:= i+1;}
return;}

/* look for the next instance to execute */
int next_robmotion (int[0,size_robmotion-1] i, cell_robmotion tab[size_robmotion], int[0,size_robmotion-1] stop_point) {
while (i < stop_point) {
 if (tab[i].status == RUN_robmotion || tab[i].status == STOP_robmotion) {return i;}
 i:= i+1;}
return size_robmotion-1;}

/* shutdown */
bool off_signal_robmotion (cell_robmotion tab[size_robmotion]) {
int[0,size_robmotion-1] j;
for (j:= 0; j<size_robmotion-1; j++) {
    if (tab[j].status != VOID_robmotion && tab[j].status != ETHER_robmotion) {return false;}}
return true;}

/* channels, variables and functions (robmap) */
/* channels */

urgent chan end_recv_robmap, recv_robmap, recv_urg_robmap, shuttimer_fuse_robmap, begin_fuse_robmap, inter_fuse_robmap;

	
broadcast chan end_spawn_fuse_robmap;

//chan priority default < up < insert;



/* constants & global variables */
bool shut_robmap:= false;

bool sched_robmap:= false;
bool lock_fuse_robmap:= true;
bool finished_fuse_robmap:= false;
bool tick_fuse_robmap:= false;
/* services IDs */
/* attributes, activities & functions */
const int FuseStart_robmap:= 0;
const int nserv_robmap:= 1;
const int width_robmap:= 1;
const int size_robmap:= width_robmap*2+1;
// the abort request is a negative "i" number that refers to interrupting the element whose index is i+size-1 
const int kill_robmap:= -1*size_robmap;

/* services with validate */

/* none (urgent reaction of CT with no request in the mbox) */
const int none_robmap:= kill_robmap -1;

/* status */
// this choice is deleberate to ease manipulating interruptions
const int RUN_robmap:= 0;
const int WAIT_robmap:= 1;
const int STOP_robmap:= 2;
const int ETHER_robmap:= 3; 
const int VOID_robmap:= 4;

/* activities array */
/* structure */ 
typedef struct {int [-1,width_robmap-1] name; int [1,2] inst; int [RUN_robmap,VOID_robmap] status;} cell_robmap;
/* initialisation */
cell_robmap tab_robmap[size_robmap] := { {FuseStart_robmap,1,VOID_robmap}, {FuseStart_robmap,2,VOID_robmap}, {-1,1,VOID_robmap} }; 
int [none_robmap,nserv_robmap-1] req_robmap:= kill_robmap;


cell_robmap turn_fuse_robmap:={-1,1,VOID_robmap};


/* functions */

/* abort and kill effect */
	
	
void interrupt_cntrl_robmap (int[none_robmap,-1] i, cell_robmap &tab[size_robmap], bool &shut) {
int[0,size_robmap-1] j;
if (i==none_robmap) {return;}
if (i!=kill_robmap) {
            if (tab[i+size_robmap-1].status<STOP_robmap) {tab[i+size_robmap-1].status += STOP_robmap;}
						return;}
for (j:=0; j<size_robmap-1; j++) {
                    if (tab[j].status<STOP_robmap) {tab[j].status += STOP_robmap;}}
shut := true;
}

/* clear and launch */
void launch_serv_robmap (cell_robmap &tab[size_robmap]) {
int i,j;
bool launch:= true;
for (i:=0; i<size_robmap-1; i++) {
            if (tab[i].status==ETHER_robmap) {tab[i].status:=VOID_robmap;}//final replies
}
for (i:=0; i<size_robmap-1; i++) {
    if (tab[i].status==WAIT_robmap) {
   if (tab[i].name==FuseStart_robmap) {
   for (j:= 0; (j<size_robmap-1 && launch); j++) {
                if (j!=i && (tab[j].name == FuseStart_robmap) && tab[j].status!=VOID_robmap) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_robmap;}
               else {launch:= true;}}
       }
}
}                    
/* interrupt incompatible instances */
void manage_intterupt_robmap (int[0,nserv_robmap-1] s, int[0,size_robmap-2] i, cell_robmap &tab[size_robmap]) {
int[0,size_robmap-1] j;	
	if (s == FuseStart_robmap) {
		for (j:= 0; j<size_robmap-1; j++) {
		if (j != i && (tab[j].name == FuseStart_robmap) && tab[j].status<2) {tab[j].status += 2;}}
				return;}
}

/* update status of terminated services */
void update_robmap (bool &finished, int[0,size_robmap-2] i, cell_robmap &tab[size_robmap]) {
if (finished) {finished:= false;
                tab[i].status:= ETHER_robmap;}
}

/* signal the end of at least an activity */
bool sched_cntrl_robmap (cell_robmap tab[size_robmap]) {
int[0,size_robmap-1] i;
for (i:=0; i<size_robmap-1; i++) {
                       if (tab[i].status == ETHER_robmap) {return true;}}
return false;}

/* look for a slot and interrupt if necesary */
void slot_search_robmap (int[0,width_robmap-1] a, cell_robmap &tab[size_robmap]) {
int[0,size_robmap-1] i:= 0;
while (tab[i].name != a) {i:= i+1;}
while (tab[i].name == a) {if (tab[i].status == VOID_robmap)
                           {tab[i].status := WAIT_robmap;
                            manage_intterupt_robmap(a, i, tab);
                            return;}
                            i:= i+1;}
return;}

/* look for the next instance to execute */
int next_robmap (int[0,size_robmap-1] i, cell_robmap tab[size_robmap], int[0,size_robmap-1] stop_point) {
while (i < stop_point) {
 if (tab[i].status == RUN_robmap || tab[i].status == STOP_robmap) {return i;}
 i:= i+1;}
return size_robmap-1;}

/* shutdown */
bool off_signal_robmap (cell_robmap tab[size_robmap]) {
int[0,size_robmap-1] j;
for (j:= 0; j<size_robmap-1; j++) {
    if (tab[j].status != VOID_robmap && tab[j].status != ETHER_robmap) {return false;}}
return true;}

/* channels, variables and functions (roblaser) */
/* channels */

urgent chan end_recv_roblaser, recv_roblaser, recv_urg_roblaser, shuttimer_scan_roblaser, begin_scan_roblaser, inter_scan_roblaser;

	
broadcast chan end_spawn_scan_roblaser;

//chan priority default < up < insert;



/* constants & global variables */
bool shut_roblaser:= false;

bool sched_roblaser:= false;
bool lock_scan_roblaser:= true;
bool finished_scan_roblaser:= false;
bool tick_scan_roblaser:= false;
/* services IDs */
/* attributes, activities & functions */
const int ScanMap_roblaser:= 0;
const int nserv_roblaser:= 1;
const int width_roblaser:= 1;
const int size_roblaser:= width_roblaser*2+1;
// the abort request is a negative "i" number that refers to interrupting the element whose index is i+size-1 
const int kill_roblaser:= -1*size_roblaser;

/* services with validate */

/* none (urgent reaction of CT with no request in the mbox) */
const int none_roblaser:= kill_roblaser -1;

/* status */
// this choice is deleberate to ease manipulating interruptions
const int RUN_roblaser:= 0;
const int WAIT_roblaser:= 1;
const int STOP_roblaser:= 2;
const int ETHER_roblaser:= 3; 
const int VOID_roblaser:= 4;

/* activities array */
/* structure */ 
typedef struct {int [-1,width_roblaser-1] name; int [1,2] inst; int [RUN_roblaser,VOID_roblaser] status;} cell_roblaser;
/* initialisation */
cell_roblaser tab_roblaser[size_roblaser] := { {ScanMap_roblaser,1,VOID_roblaser}, {ScanMap_roblaser,2,VOID_roblaser}, {-1,1,VOID_roblaser} }; 
int [none_roblaser,nserv_roblaser-1] req_roblaser:= kill_roblaser;


cell_roblaser turn_scan_roblaser:={-1,1,VOID_roblaser};


/* functions */

/* abort and kill effect */
	
	
void interrupt_cntrl_roblaser (int[none_roblaser,-1] i, cell_roblaser &tab[size_roblaser], bool &shut) {
int[0,size_roblaser-1] j;
if (i==none_roblaser) {return;}
if (i!=kill_roblaser) {
            if (tab[i+size_roblaser-1].status<STOP_roblaser) {tab[i+size_roblaser-1].status += STOP_roblaser;}
						return;}
for (j:=0; j<size_roblaser-1; j++) {
                    if (tab[j].status<STOP_roblaser) {tab[j].status += STOP_roblaser;}}
shut := true;
}

/* clear and launch */
void launch_serv_roblaser (cell_roblaser &tab[size_roblaser]) {
int i,j;
bool launch:= true;
for (i:=0; i<size_roblaser-1; i++) {
            if (tab[i].status==ETHER_roblaser) {tab[i].status:=VOID_roblaser;}//final replies
}
for (i:=0; i<size_roblaser-1; i++) {
    if (tab[i].status==WAIT_roblaser) {
   if (tab[i].name==ScanMap_roblaser) {
   for (j:= 0; (j<size_roblaser-1 && launch); j++) {
                if (j!=i && (tab[j].name == ScanMap_roblaser) && tab[j].status!=VOID_roblaser) {
                    launch:= false;}}
               if (launch) {tab[i].status:=RUN_roblaser;}
               else {launch:= true;}}
       }
}
}                    
/* interrupt incompatible instances */
void manage_intterupt_roblaser (int[0,nserv_roblaser-1] s, int[0,size_roblaser-2] i, cell_roblaser &tab[size_roblaser]) {
int[0,size_roblaser-1] j;	
	if (s == ScanMap_roblaser) {
		for (j:= 0; j<size_roblaser-1; j++) {
		if (j != i && (tab[j].name == ScanMap_roblaser) && tab[j].status<2) {tab[j].status += 2;}}
				return;}
}

/* update status of terminated services */
void update_roblaser (bool &finished, int[0,size_roblaser-2] i, cell_roblaser &tab[size_roblaser]) {
if (finished) {finished:= false;
                tab[i].status:= ETHER_roblaser;}
}

/* signal the end of at least an activity */
bool sched_cntrl_roblaser (cell_roblaser tab[size_roblaser]) {
int[0,size_roblaser-1] i;
for (i:=0; i<size_roblaser-1; i++) {
                       if (tab[i].status == ETHER_roblaser) {return true;}}
return false;}

/* look for a slot and interrupt if necesary */
void slot_search_roblaser (int[0,width_roblaser-1] a, cell_roblaser &tab[size_roblaser]) {
int[0,size_roblaser-1] i:= 0;
while (tab[i].name != a) {i:= i+1;}
while (tab[i].name == a) {if (tab[i].status == VOID_roblaser)
                           {tab[i].status := WAIT_roblaser;
                            manage_intterupt_roblaser(a, i, tab);
                            return;}
                            i:= i+1;}
return;}

/* look for the next instance to execute */
int next_roblaser (int[0,size_roblaser-1] i, cell_roblaser tab[size_roblaser], int[0,size_roblaser-1] stop_point) {
while (i < stop_point) {
 if (tab[i].status == RUN_roblaser || tab[i].status == STOP_roblaser) {return i;}
 i:= i+1;}
return size_roblaser-1;}

/* shutdown */
bool off_signal_roblaser (cell_roblaser tab[size_roblaser]) {
int[0,size_roblaser-1] j;
for (j:= 0; j<size_roblaser-1; j++) {
    if (tab[j].status != VOID_roblaser && tab[j].status != ETHER_roblaser) {return false;}}
return true;}
	


/* scheduling */


void update_queue (int &T[size_sched], int &p[size_sched], int &w[size_sched]) {
int i;
for (i:= 0; i<size_sched; i++) {
	if (p[i] >= 0) {
	T[p[i]]:= period[i] - w[i];}
}
}

void dequeue (int &T[size_sched], int &p[size_sched]) {
int i;
int i_m:= 0;
int m:= T[0];

/* find the cell corresponding to the task to dequeue */

for (i:= 1; i<len; i++) {
	if (T[i] < m) {
	i_m:= i;
	m:= T[i];}
}

/* shift tasks indices */

for (i:= 0; i<size_sched; i++) {
	if (p[i] == i_m) {p[i]:= -1;}
	else if (p[i] > i_m) {p[i]--;}
}

/* shift priorities values */

for (i:= i_m+1; i<len; i++) {
	T[i-1]:= T[i];
}
T[i-1] := -2;
}

process control_robloco(urgent chan &recv_robloco, urgent chan &exe, bool &shut_robloco, urgent chan &recv_urg_robloco, cell_robloco &tab_robloco[size_robloco], bool &sched_robloco, broadcast chan &end_spawn_track_robloco, int[none_robloco,nserv_robloco-1] &req_robloco, bool &mutex_robloco[length_mut_robloco]) {





clock x;
state
    shutdown,
    receive,
    unspawned,
    decode,
    manage,
    wait,
    finish;
commit
    decode,
    manage,
    finish;
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_track_robloco?; },
    receive -> decode { guard sched_robloco; sync recv_urg_robloco?; assign sched_robloco:= false; },
    decode -> finish { guard req_robloco < 0; assign interrupt_cntrl_robloco(req_robloco,tab_robloco,shut_robloco); },
    manage -> finish { assign slot_search_robloco (req_robloco, tab_robloco); },
    decode -> manage { guard req_robloco >=InitPosPort_robloco  && 
req_robloco <=TrackSpeedStart_robloco; },
    finish -> receive { guard !shut_robloco; sync end_recv_robloco!; assign launch_serv_robloco(tab_robloco); },
    receive -> decode { guard !sched_robloco; sync recv_robloco?; },
    finish -> wait { guard shut_robloco; },
    wait -> shutdown { guard off_signal_robloco(tab_robloco); sync exe!; assign launch_serv_robloco(tab_robloco); };
}

process Timer_odo_robloco(bool &tick_odo_robloco, urgent chan &shuttimer_odo_robloco) {





clock x;
state
    shutdown,
    start { x <= 50 };
init
    start;
trans
    start -> start { guard x==50; assign tick_odo_robloco:= true, x:=0; },
    start -> shutdown { sync shuttimer_odo_robloco?; };
}

process Manager_odo_robloco(urgent chan &exe, bool &lock_odo_robloco, bool &shut_robloco, urgent chan &begin_odo_robloco, urgent chan &inter_odo_robloco, cell_robloco &turn_odo_robloco , cell_robloco &tab_robloco[size_robloco], bool &finished_odo_robloco, bool &sched_robloco, urgent chan &shuttimer_odo_robloco, bool &tick_odo_robloco) {






clock x;
int u,d;

int i:= 0;
int j:= 0;
state
    start,
    manage,
    ask { x<=50 },
    count,
    decide,
    error;
commit
    count,
    decide;
init
    start;
trans
    manage -> manage { guard lock_odo_robloco && i<size_robloco-1; sync inter_odo_robloco!; assign update_robloco (finished_odo_robloco, j, tab_robloco),
j:= i, i:= next_robloco (i+1, tab_robloco, 4), turn_odo_robloco := tab_robloco[i]; },
    manage -> manage { guard lock_odo_robloco && i<size_robloco-1; sync begin_odo_robloco!; assign update_robloco (finished_odo_robloco, j, tab_robloco),
j:= i, i:= next_robloco (i+1, tab_robloco, 4), 
turn_odo_robloco := tab_robloco[i]; },
    manage -> start { guard lock_odo_robloco && 
i == size_robloco-1; sync exe!; assign nc++, 
update_robloco (finished_odo_robloco, j, tab_robloco), 
i:= 0, sched_robloco:= sched_cntrl_robloco(tab_robloco), 
finished_odo_robloco:= false; },
    start -> ask { guard !(next_robloco(i,tab_robloco,4)==size_robloco-1)  && 
tick_odo_robloco; sync insert!; assign p[0]:= len, x:= 0, w[0]:= 25, u:= period[0], d:= 0, 
tick_odo_robloco:= false; },
    ask -> error { guard x== 50; },
    ask -> count { sync up?; },
    count -> count { guard x< w[0]-1; sync cnt?; assign u:= w[0]-1, w[0]:= (u+d)/2; },
    count -> count { guard x> w[0]+1; sync cnt?; assign d:= w[0]+1, w[0]:= (u+d)/2; },
    count -> decide { guard x>= w[0] && 
x< w[0]+1; sync cnt?; assign rel_count++, 
d:=w[0], u:= 50; },
    count -> decide { guard x>= w[0]-1 && x< w[0]; sync cnt?; assign rel_count++, w[0]:= w[0]-1, d:=w[0], u:= 50; },
    count -> decide { guard x== w[0]+1; sync cnt?; assign rel_count++, w[0]:= w[0]+1, d:=w[0], u:= 50; },
    decide -> ask { guard p[0]!=-1; sync en?; },
    decide -> start { guard p[0]==-1 && 
next_robloco(i,tab_robloco,4)==size_robloco-1; sync en?; assign p[0]:=-2, nc++, 
update_robloco (finished_odo_robloco, j, tab_robloco), 
i:= 0, sched_robloco:= sched_cntrl_robloco(tab_robloco), 
finished_odo_robloco:= false; },
    decide -> manage { guard p[0]==-1  && 
!(next_robloco(i,tab_robloco,4)==size_robloco-1); sync en?; assign p[0]:=-2, i:= next_robloco (i, tab_robloco, 4), 
turn_odo_robloco := tab_robloco[i]; };
}

process Perm_odo_robloco(broadcast chan &end_spawn_odo_robloco, urgent chan &exe, bool &mutex_robloco[length_mut_robloco], bool &ports[nports]) {






clock x;
state
    start_ { x<=10 },
    ether_;
init
    start_;
trans
    start_ -> ether_ { guard x>=8; sync end_spawn_odo_robloco!; assign x:=0; };
}

process InitPosPort_robloco_(urgent chan &begin_odo_robloco, urgent chan &inter_odo_robloco, bool &lock_odo_robloco,  const int instance, cell_robloco &turn_odo_robloco, bool &finished_odo_robloco, urgent chan &exe, bool &mutex_robloco[length_mut_robloco], bool &ports[nports]) {






clock x;
state
    start_,
    start_2 { x<=10 },
    ether_;
init
    ether_;
trans
    ether_ -> start_ { guard turn_odo_robloco.name == InitPosPort_robloco &&
turn_odo_robloco.inst == instance && 
turn_odo_robloco.status == RUN_robloco; sync begin_odo_robloco?; assign lock_odo_robloco:= false, x:= 0; },
    start_ -> start_2 { guard !ports[0]; sync exe!; assign x:=0, ports[0]:= true; },
    start_2 -> ether_ { guard x>=8; assign lock_odo_robloco:= true, finished_odo_robloco:= true, ports[0]:= false; },
    ether_ -> ether_ { guard turn_odo_robloco.name == InitPosPort_robloco && turn_odo_robloco.inst == instance && turn_odo_robloco.status == STOP_robloco; sync inter_odo_robloco?; assign finished_odo_robloco:= true; };
}

process TrackOdoStart_robloco_(urgent chan &begin_odo_robloco, urgent chan &inter_odo_robloco, bool &lock_odo_robloco,  const int instance, cell_robloco &turn_odo_robloco, bool &finished_odo_robloco, urgent chan &exe, bool &mutex_robloco[length_mut_robloco], bool &ports[nports]) {






clock x;
state
    start_ { x<=5 },
    odo_compute_,
    odo_compute_2 { x<=15 },
    stop_ { x<=10 },
    pause_odo_compute_,
    ether_;
init
    ether_;
trans
    ether_ -> start_ { guard turn_odo_robloco.name == TrackOdoStart_robloco &&
turn_odo_robloco.inst == instance && 
turn_odo_robloco.status == RUN_robloco; sync begin_odo_robloco?; assign lock_odo_robloco:= false, x:= 0; },
    start_ -> odo_compute_ { guard x>=3; assign x:=0; },
    odo_compute_ -> odo_compute_2 { guard !mutex_robloco[0]/*in conflict with InitTrackParameters_track*/ &&
!mutex_robloco[1]/*in conflict with tssExec_TrackSpeedStart*/ &&
!mutex_robloco[2]/*in conflict with tssStop_TrackSpeedStart*/ &&
!ports[0]; sync exe!; assign x:=0, mutex_robloco[3]:= true, ports[0]:= true; },
    odo_compute_2 -> pause_odo_compute_ { guard x>=10; assign lock_odo_robloco:= true, mutex_robloco[3]:= false, ports[0]:= false; },
    stop_ -> ether_ { guard x==10; assign lock_odo_robloco:= true, finished_odo_robloco:= true; },
    pause_odo_compute_ -> odo_compute_ { guard turn_odo_robloco.name == TrackOdoStart_robloco && turn_odo_robloco.inst == instance && 
turn_odo_robloco.status == RUN_robloco; sync begin_odo_robloco?; assign lock_odo_robloco:= false, x:= 0; },
    pause_odo_compute_ -> stop_ { guard turn_odo_robloco.name == TrackOdoStart_robloco && turn_odo_robloco.inst == instance && 
turn_odo_robloco.status == STOP_robloco; sync inter_odo_robloco?; assign lock_odo_robloco:= false, x:= 0; },
    ether_ -> stop_ { guard turn_odo_robloco.name == TrackOdoStart_robloco &&
turn_odo_robloco.inst == instance &&
turn_odo_robloco.status == STOP_robloco; sync inter_odo_robloco?; assign lock_odo_robloco:= false, x:= 0; };
}

process Timer_track_robloco(bool &tick_track_robloco, urgent chan &shuttimer_track_robloco, broadcast chan &end_spawn_odo_robloco) {





clock x;
state
    shutdown,
    start { x <= 50 },
    idle;
init
    idle;
trans
    start -> start { guard x==50; assign tick_track_robloco:= true, x:=0; },
    start -> shutdown { sync shuttimer_track_robloco?; },
    idle -> start { sync end_spawn_odo_robloco?; assign x:=0; };
}

process Manager_track_robloco(urgent chan &exe, bool &lock_track_robloco, bool &shut_robloco, urgent chan &begin_track_robloco, urgent chan &inter_track_robloco, cell_robloco &turn_track_robloco , cell_robloco &tab_robloco[size_robloco], bool &finished_track_robloco, bool &sched_robloco, urgent chan &shuttimer_track_robloco, bool &tick_track_robloco) {






clock x;
int u,d;

int i:= 4;
int j:= 4;
state
    start,
    manage,
    ask { x<=50 },
    count,
    decide,
    error;
commit
    count,
    decide;
init
    start;
trans
    manage -> manage { guard lock_track_robloco && i<size_robloco-1; sync inter_track_robloco!; assign update_robloco (finished_track_robloco, j, tab_robloco),
j:= i, i:= next_robloco (i+1, tab_robloco, 6), turn_track_robloco := tab_robloco[i]; },
    manage -> manage { guard lock_track_robloco && i<size_robloco-1; sync begin_track_robloco!; assign update_robloco (finished_track_robloco, j, tab_robloco),
j:= i, i:= next_robloco (i+1, tab_robloco, 6), turn_track_robloco := tab_robloco[i]; },
    manage -> start { guard lock_track_robloco && i == size_robloco-1; sync exe!; assign nc++, 
update_robloco (finished_track_robloco, j, tab_robloco), 
i:= 4, sched_robloco:= sched_cntrl_robloco(tab_robloco), 
finished_track_robloco:= false; },
    start -> ask { guard !(next_robloco(i,tab_robloco,6)==size_robloco-1)  && tick_track_robloco; sync insert!; assign p[1]:= len, x:= 0, w[1]:= 25, u:= period[1], d:= 0, tick_track_robloco:= false; },
    ask -> error { guard x== 50; },
    ask -> count { sync up?; },
    count -> count { guard x< w[1]-1; sync cnt?; assign u:= w[1]-1, w[1]:= (u+d)/2; },
    count -> count { guard x> w[1]+1; sync cnt?; assign d:= w[1]+1, w[1]:= (u+d)/2; },
    count -> decide { guard x>= w[1] && x< w[1]+1; sync cnt?; assign rel_count++, d:=w[1], u:= 50; },
    count -> decide { guard x>= w[1]-1 && x< w[1]; sync cnt?; assign rel_count++, w[1]:= w[1]-1, d:=w[1], u:= 50; },
    count -> decide { guard x== w[1]+1; sync cnt?; assign rel_count++, w[1]:= w[1]+1, d:=w[1], u:= 50; },
    decide -> ask { guard p[1]!=-1; sync en?; },
    decide -> start { guard p[1]==-1 && next_robloco(i,tab_robloco,6)==size_robloco-1; sync en?; assign p[1]:=-2, nc++, 
update_robloco (finished_track_robloco, j, tab_robloco), 
i:= 4, sched_robloco:= sched_cntrl_robloco(tab_robloco), 
finished_track_robloco:= false; },
    decide -> manage { guard p[1]==-1  && !(next_robloco(i,tab_robloco,6)==size_robloco-1); sync en?; assign p[1]:=-2, i:= next_robloco (i, tab_robloco, 6), 
turn_track_robloco := tab_robloco[i]; };
}

process Perm_track_robloco(broadcast chan &end_spawn_track_robloco, broadcast chan &end_spawn_odo_robloco, urgent chan &exe, bool &mutex_robloco[length_mut_robloco], bool &ports[nports]) {






clock x;
state
    unspawned,
    start_,
    start_2 { x<=10 },
    ether_;
init
    unspawned;
trans
    unspawned -> start_ { sync end_spawn_odo_robloco?; assign x:=0; },
    start_ -> start_2 { guard !mutex_robloco[3]; sync exe!; assign x:=0, mutex_robloco[0]:= true; },
    start_2 -> ether_ { guard x>=8; sync end_spawn_track_robloco!; assign x:=0, mutex_robloco[0]:= false; };
}

process TrackSpeedStart_robloco_(urgent chan &begin_track_robloco, urgent chan &inter_track_robloco, bool &lock_track_robloco,  const int instance, cell_robloco &turn_track_robloco, bool &finished_track_robloco, urgent chan &exe, bool &mutex_robloco[length_mut_robloco], bool &ports[nports]) {






clock x;
state
    start_,
    start_2 { x<=5 },
    track_,
    track_2 { x<=10 },
    stop_,
    stop_2 { x<=10 },
    pause_track_,
    ether_;
init
    ether_;
trans
    ether_ -> start_ { guard turn_track_robloco.name == TrackSpeedStart_robloco && 
turn_track_robloco.inst == instance && 
turn_track_robloco.status == RUN_robloco; sync begin_track_robloco?; assign lock_track_robloco:= false, x:= 0; },
    start_ -> start_2 { guard !ports[1]; sync exe!; assign x:=0, 
ports[1]:= true; },
    start_2 -> track_ { guard x>=3; assign x:=0, ports[1]:= false; },
    track_ -> track_2 { guard !mutex_robloco[3]/*in conflict with odo_compute_TrackOdoStart*/ && !ports[1]; sync exe!; assign x:=0, mutex_robloco[1]:= true, ports[1]:= true; },
    track_2 -> pause_track_ { guard x>=0; assign lock_track_robloco:= true, 
mutex_robloco[1]:= false, 
ports[1]:= false; },
    stop_ -> stop_2 { guard !mutex_robloco[3]; sync exe!; assign x:=0, mutex_robloco[2]:= true; },
    stop_2 -> ether_ { guard x==10; assign lock_track_robloco:= true, 
finished_track_robloco:= true, 
mutex_robloco[2]:= false; },
    pause_track_ -> track_ { guard turn_track_robloco.name == TrackSpeedStart_robloco && 
turn_track_robloco.inst == instance && 
turn_track_robloco.status == RUN_robloco; sync begin_track_robloco?; assign lock_track_robloco:= false, 
x:= 0; },
    pause_track_ -> stop_ { guard turn_track_robloco.name == TrackSpeedStart_robloco && 
turn_track_robloco.inst == instance && 
turn_track_robloco.status == STOP_robloco; sync inter_track_robloco?; assign lock_track_robloco:= false, x:= 0; },
    ether_ -> stop_ { guard turn_track_robloco.name == TrackSpeedStart_robloco && 
turn_track_robloco.inst == instance && 
turn_track_robloco.status == STOP_robloco; sync inter_track_robloco?; assign lock_track_robloco:= false, x:= 0; };
}

process control_robmotion(urgent chan &recv_robmotion, urgent chan &exe, bool &shut_robmotion, urgent chan &recv_urg_robmotion, cell_robmotion &tab_robmotion[size_robmotion], bool &sched_robmotion, broadcast chan &end_spawn_plan_robmotion, int[none_robmotion,nserv_robmotion-1] &req_robmotion) {





clock x;
state
    shutdown,
    receive,
    unspawned,
    decode,
    manage,
    wait,
    finish;
commit
    decode,
    manage,
    finish;
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_plan_robmotion?; },
    receive -> decode { guard sched_robmotion; sync recv_urg_robmotion?; assign sched_robmotion:= false; },
    decode -> finish { guard req_robmotion < 0; assign interrupt_cntrl_robmotion(req_robmotion,tab_robmotion,shut_robmotion); },
    manage -> finish { assign slot_search_robmotion (req_robmotion, tab_robmotion); },
    decode -> manage { guard req_robmotion >=GotoPosition_robmotion  && 
req_robmotion <=GotoPosition_robmotion; },
    finish -> receive { guard !shut_robmotion; sync end_recv_robmotion!; assign launch_serv_robmotion(tab_robmotion); },
    receive -> decode { guard !sched_robmotion; sync recv_robmotion?; },
    finish -> wait { guard shut_robmotion; },
    wait -> shutdown { guard off_signal_robmotion(tab_robmotion); sync exe!; assign launch_serv_robmotion(tab_robmotion); };
}

process Timer_plan_robmotion(bool &tick_plan_robmotion, urgent chan &shuttimer_plan_robmotion) {





clock x;
state
    shutdown,
    start { x <= 200 };
init
    start;
trans
    start -> start { guard x==200; assign tick_plan_robmotion:= true, x:=0; },
    start -> shutdown { sync shuttimer_plan_robmotion?; };
}

process Manager_plan_robmotion(urgent chan &exe, bool &lock_plan_robmotion, bool &shut_robmotion, urgent chan &begin_plan_robmotion, urgent chan &inter_plan_robmotion, cell_robmotion &turn_plan_robmotion , cell_robmotion &tab_robmotion[size_robmotion], bool &finished_plan_robmotion, bool &sched_robmotion, urgent chan &shuttimer_plan_robmotion, bool &tick_plan_robmotion) {






clock x;
int u,d;

int i:= 0;
int j:= 0;
state
    start,
    manage,
    ask { x<=200 },
    count,
    decide,
    error;
commit
    count,
    decide;
init
    start;
trans
    decide -> manage { guard p[2]==-1; sync en?; assign p[2]:=-2, i:= next_robmotion (i, tab_robmotion, 2), 
turn_plan_robmotion := tab_robmotion[i]; },
    manage -> manage { guard lock_plan_robmotion && i<size_robmotion-1; sync inter_plan_robmotion!; assign update_robmotion (finished_plan_robmotion, j, tab_robmotion),
j:= i, i:= next_robmotion (i+1, tab_robmotion, 2), turn_plan_robmotion := tab_robmotion[i]; },
    manage -> manage { guard lock_plan_robmotion && i<size_robmotion-1; sync begin_plan_robmotion!; assign update_robmotion (finished_plan_robmotion, j, tab_robmotion),
j:= i, i:= next_robmotion (i+1, tab_robmotion, 2), turn_plan_robmotion := tab_robmotion[i]; },
    manage -> start { guard lock_plan_robmotion && i == size_robmotion-1; sync exe!; assign nc++, update_robmotion (finished_plan_robmotion, j, tab_robmotion), i:= 0, 
sched_robmotion:= sched_cntrl_robmotion(tab_robmotion), 
finished_plan_robmotion:= false; },
    start -> ask { guard tick_plan_robmotion; sync insert!; assign p[2]:= len, w[2]:= 100, u:= period[2], d:= 0, 
tick_plan_robmotion:= false, x:=0; },
    ask -> error { guard x== 200; },
    ask -> count { sync up?; },
    count -> count { guard x< w[2]-1; sync cnt?; assign u:= w[2]-1, w[2]:= (u+d)/2; },
    count -> count { guard x> w[2]+1; sync cnt?; assign d:= w[2]+1, w[2]:= (u+d)/2; },
    count -> decide { guard x>= w[2] && x< w[2]+1; sync cnt?; assign rel_count++, d:=w[2], u:= 200; },
    count -> decide { guard x>= w[2]-1 && x< w[2]; sync cnt?; assign rel_count++, w[2]:= w[2]-1, d:=w[2], u:= 200; },
    count -> decide { guard x== w[2]+1; sync cnt?; assign rel_count++, w[2]:= w[2]+1, d:=w[2], u:= 200; },
    decide -> ask { guard p[2]!=-1; sync en?; },
    decide -> start { guard p[2]==-1 && 
next_robmotion(i,tab_robmotion,2)==size_robmotion-1; sync en?; assign p[2]:=-2, nc++, 
update_robmotion (finished_plan_robmotion, j, tab_robmotion), i:= 0, 
sched_robmotion:= sched_cntrl_robmotion(tab_robmotion), 
finished_plan_robmotion:= false; };
}

process Perm_plan_robmotion(broadcast chan &end_spawn_plan_robmotion, urgent chan &exe, bool &ports[nports]) {






clock x;
state
    start_ { x<=10 },
    ether_;
init
    start_;
trans
    start_ -> ether_ { guard x>=8; sync end_spawn_plan_robmotion!; assign x:=0; };
}

process GotoPosition_robmotion_(urgent chan &begin_plan_robmotion, urgent chan &inter_plan_robmotion, bool &lock_plan_robmotion,  const int instance, cell_robmotion &turn_plan_robmotion, bool &finished_plan_robmotion, urgent chan &exe, bool &ports[nports]) {






clock x;
state
    start_,
    start_2 { x<=5 },
    read_ports_,
    read_ports_2 { x<=10 },
    compute_speed_,
    compute_speed_2 { x<=15 },
    pause_read_ports_,
    ether_;
init
    ether_;
trans
    ether_ -> start_ { guard turn_plan_robmotion.name == GotoPosition_robmotion && 
turn_plan_robmotion.inst == instance && 
turn_plan_robmotion.status == RUN_robmotion; sync begin_plan_robmotion?; assign lock_plan_robmotion:= false, x:= 0; },
    start_ -> start_2 { guard !ports[0] /* uses (in) the port E_current_position of the component robloco */ 
&& !ports[2]; sync exe!; assign x:=0, ports[0]:= true, ports[2]:= true; },
    start_2 -> read_ports_ { guard x>=3; assign x:=0, ports[0]:= false, ports[2]:= false; },
    read_ports_ -> read_ports_2 { guard !ports[0] /* uses (in) the port E_current_position of the component robloco */ && 
!ports[2]; sync exe!; assign x:=0, ports[0]:= true, ports[2]:= true; },
    read_ports_2 -> compute_speed_ { guard x>=0; assign x:=0, ports[0]:= false, ports[2]:= false; },
    compute_speed_ -> compute_speed_2 { guard !ports[1]; sync exe!; assign x:=0, ports[1]:= true; },
    compute_speed_2 -> pause_read_ports_ { guard x>=13; assign lock_plan_robmotion:= true, ports[1]:= false; },
    compute_speed_2 -> ether_ { guard x>=13; assign lock_plan_robmotion:= true, finished_plan_robmotion:= true, ports[1]:= false; },
    pause_read_ports_ -> read_ports_ { guard turn_plan_robmotion.name == GotoPosition_robmotion && 
turn_plan_robmotion.inst == instance && 
turn_plan_robmotion.status == RUN_robmotion; sync begin_plan_robmotion?; assign lock_plan_robmotion:= false, x:= 0; },
    pause_read_ports_ -> ether_ { guard turn_plan_robmotion.name == GotoPosition_robmotion && 
turn_plan_robmotion.inst == instance && 
turn_plan_robmotion.status == STOP_robmotion; sync inter_plan_robmotion?; assign finished_plan_robmotion:= true; },
    ether_ -> ether_ { guard turn_plan_robmotion.name == GotoPosition_robmotion && 
turn_plan_robmotion.inst == instance && 
turn_plan_robmotion.status == STOP_robmotion; sync inter_plan_robmotion?; assign finished_plan_robmotion:= true; };
}

process control_robmap(urgent chan &recv_robmap, urgent chan &exe, bool &shut_robmap, urgent chan &recv_urg_robmap, cell_robmap &tab_robmap[size_robmap], bool &sched_robmap, broadcast chan &end_spawn_fuse_robmap, int[none_robmap,nserv_robmap-1] &req_robmap) {





clock x;
state
    shutdown,
    receive,
    unspawned,
    decode,
    manage,
    wait,
    finish;
commit
    decode,
    manage,
    finish;
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_fuse_robmap?; },
    receive -> decode { guard sched_robmap; sync recv_urg_robmap?; assign sched_robmap:= false; },
    decode -> finish { guard req_robmap < 0; assign interrupt_cntrl_robmap(req_robmap,tab_robmap,shut_robmap); },
    manage -> finish { assign slot_search_robmap (req_robmap, tab_robmap); },
    decode -> manage { guard req_robmap >=FuseStart_robmap  && 
req_robmap <=FuseStart_robmap; },
    finish -> receive { guard !shut_robmap; sync end_recv_robmap!; assign launch_serv_robmap(tab_robmap); },
    receive -> decode { guard !sched_robmap; sync recv_robmap?; },
    finish -> wait { guard shut_robmap; },
    wait -> shutdown { guard off_signal_robmap(tab_robmap); sync exe!; assign launch_serv_robmap(tab_robmap); };
}

process Timer_fuse_robmap(bool &tick_fuse_robmap, urgent chan &shuttimer_fuse_robmap) {





clock x;
state
    shutdown,
    start { x <= 50 };
init
    start;
trans
    start -> start { guard x==50; assign tick_fuse_robmap:= true, x:=0; },
    start -> shutdown { sync shuttimer_fuse_robmap?; };
}

process Manager_fuse_robmap(urgent chan &exe, bool &lock_fuse_robmap, bool &shut_robmap, urgent chan &begin_fuse_robmap, urgent chan &inter_fuse_robmap, cell_robmap &turn_fuse_robmap , cell_robmap &tab_robmap[size_robmap], bool &finished_fuse_robmap, bool &sched_robmap, urgent chan &shuttimer_fuse_robmap, bool &tick_fuse_robmap) {






clock x;
int u,d;

int i:= 0;
int j:= 0;
state
    start,
    manage,
    ask { x<=50 },
    count,
    decide,
    error;
commit
    count,
    decide;
init
    start;
trans
    manage -> manage { guard lock_fuse_robmap && i<size_robmap-1; sync inter_fuse_robmap!; assign update_robmap (finished_fuse_robmap, j, tab_robmap),
j:= i, i:= next_robmap (i+1, tab_robmap, 2), turn_fuse_robmap := tab_robmap[i]; },
    manage -> manage { guard lock_fuse_robmap && i<size_robmap-1; sync begin_fuse_robmap!; assign update_robmap (finished_fuse_robmap, j, tab_robmap),
j:= i, i:= next_robmap (i+1, tab_robmap, 2), turn_fuse_robmap := tab_robmap[i]; },
    manage -> start { guard lock_fuse_robmap && i == size_robmap-1; sync exe!; assign nc++, update_robmap (finished_fuse_robmap, j, tab_robmap), i:= 0, 
sched_robmap:= sched_cntrl_robmap(tab_robmap), 
finished_fuse_robmap:= false; },
    start -> ask { guard !(next_robmap(i,tab_robmap,2)==size_robmap-1)  && tick_fuse_robmap; sync insert!; assign p[3]:= len, x:= 0, w[3]:= 25, u:= period[3], d:= 0, tick_fuse_robmap:= false; },
    ask -> error { guard x== 50; },
    ask -> count { sync up?; },
    count -> count { guard x< w[3]-1; sync cnt?; assign u:= w[3]-1, w[3]:= (u+d)/2; },
    count -> count { guard x> w[3]+1; sync cnt?; assign d:= w[3]+1, w[3]:= (u+d)/2; },
    count -> decide { guard x>= w[3] && x< w[3]+1; sync cnt?; assign rel_count++, d:=w[3], u:= 50; },
    count -> decide { guard x>= w[3]-1 && x< w[3]; sync cnt?; assign rel_count++, w[3]:= w[3]-1, d:=w[3], u:= 50; },
    count -> decide { guard x== w[3]+1; sync cnt?; assign rel_count++, w[3]:= w[3]+1, d:=w[3], u:= 50; },
    decide -> ask { guard p[3]!=-1; sync en?; },
    decide -> start { guard p[3]==-1 && next_robmap(i,tab_robmap,2)==size_robmap-1; sync en?; assign p[3]:=-2, nc++, update_robmap (finished_fuse_robmap, j, tab_robmap), 
i:= 0, sched_robmap:= sched_cntrl_robmap(tab_robmap), 
finished_fuse_robmap:= false; },
    decide -> manage { guard p[3]==-1  && !(next_robmap(i,tab_robmap,2)==size_robmap-1); sync en?; assign p[3]:=-2, i:= next_robmap (i, tab_robmap, 2), turn_fuse_robmap := tab_robmap[i]; };
}

process Perm_fuse_robmap(broadcast chan &end_spawn_fuse_robmap, urgent chan &exe, bool &ports[nports]) {






clock x;
state
    start_ { x<=10 },
    ether_;
init
    start_;
trans
    start_ -> ether_ { guard x>=8; sync end_spawn_fuse_robmap!; assign x:=0; };
}

process FuseStart_robmap_(urgent chan &begin_fuse_robmap, urgent chan &inter_fuse_robmap, bool &lock_fuse_robmap,  const int instance, cell_robmap &turn_fuse_robmap, bool &finished_fuse_robmap, urgent chan &exe, bool &ports[nports]) {






clock x;
state
    start_,
    start_2 { x<=10 },
    read_laser_,
    read_laser_2 { x<=10 },
    fuse_map_,
    fuse_map_2 { x<=20 },
    stop_ { x<=10 },
    pause_read_laser_,
    ether_;
init
    ether_;
trans
    ether_ -> start_ { guard turn_fuse_robmap.name == FuseStart_robmap && 
turn_fuse_robmap.inst == instance && 
turn_fuse_robmap.status == RUN_robmap; sync begin_fuse_robmap?; assign lock_fuse_robmap:= false, x:= 0; },
    start_ -> start_2 { guard !ports[3]; sync exe!; assign x:=0, ports[3]:= true; },
    start_2 -> read_laser_ { guard x>=8; assign x:=0, ports[3]:= false; },
    read_laser_ -> read_laser_2 { guard !ports[3]; sync exe!; assign x:=0, ports[3]:= true; },
    read_laser_2 -> fuse_map_ { guard x>=8; assign x:=0, ports[3]:= false; },
    fuse_map_ -> fuse_map_2 { guard !ports[2]; sync exe!; assign x:=0, ports[2]:= true; },
    fuse_map_2 -> pause_read_laser_ { guard x>=18; assign lock_fuse_robmap:= true, ports[2]:= false; },
    stop_ -> ether_ { guard x==10; assign lock_fuse_robmap:= true, 
finished_fuse_robmap:= true; },
    pause_read_laser_ -> read_laser_ { guard turn_fuse_robmap.name == FuseStart_robmap && 
turn_fuse_robmap.inst == instance && 
turn_fuse_robmap.status == RUN_robmap; sync begin_fuse_robmap?; assign lock_fuse_robmap:= false, x:= 0; },
    pause_read_laser_ -> stop_ { guard turn_fuse_robmap.name == FuseStart_robmap && 
turn_fuse_robmap.inst == instance && 
turn_fuse_robmap.status == STOP_robmap; sync inter_fuse_robmap?; assign lock_fuse_robmap:= false, x:= 0; },
    ether_ -> stop_ { guard turn_fuse_robmap.name == FuseStart_robmap && 
turn_fuse_robmap.inst == instance && 
turn_fuse_robmap.status == STOP_robmap; sync inter_fuse_robmap?; assign lock_fuse_robmap:= false, x:= 0; };
}

process control_roblaser(urgent chan &recv_roblaser, urgent chan &exe, bool &shut_roblaser, urgent chan &recv_urg_roblaser, cell_roblaser &tab_roblaser[size_roblaser], bool &sched_roblaser, broadcast chan &end_spawn_scan_roblaser, int[none_roblaser,nserv_roblaser-1] &req_roblaser) {





clock x;
state
    shutdown,
    receive,
    unspawned,
    decode,
    manage,
    wait,
    finish;
commit
    decode,
    manage,
    finish;
init
    unspawned;
trans
    unspawned -> receive { sync end_spawn_scan_roblaser?; },
    receive -> decode { guard sched_roblaser; sync recv_urg_roblaser?; assign sched_roblaser:= false; },
    decode -> finish { guard req_roblaser < 0; assign interrupt_cntrl_roblaser(req_roblaser,tab_roblaser,shut_roblaser); },
    manage -> finish { assign slot_search_roblaser (req_roblaser, tab_roblaser); },
    decode -> manage { guard req_roblaser >=ScanMap_roblaser  && 
req_roblaser <=ScanMap_roblaser; },
    finish -> receive { guard !shut_roblaser; sync end_recv_roblaser!; assign launch_serv_roblaser(tab_roblaser); },
    receive -> decode { guard !sched_roblaser; sync recv_roblaser?; },
    finish -> wait { guard shut_roblaser; },
    wait -> shutdown { guard off_signal_roblaser(tab_roblaser); sync exe!; assign launch_serv_roblaser(tab_roblaser); };
}

process Timer_scan_roblaser(bool &tick_scan_roblaser, urgent chan &shuttimer_scan_roblaser) {





clock x;
state
    shutdown,
    start { x <= 50 };
init
    start;
trans
    start -> start { guard x==50; assign tick_scan_roblaser:= true, x:=0; },
    start -> shutdown { sync shuttimer_scan_roblaser?; };
}

process Manager_scan_roblaser(urgent chan &exe, bool &lock_scan_roblaser, bool &shut_roblaser, urgent chan &begin_scan_roblaser, urgent chan &inter_scan_roblaser, cell_roblaser &turn_scan_roblaser , cell_roblaser &tab_roblaser[size_roblaser], bool &finished_scan_roblaser, bool &sched_roblaser, urgent chan &shuttimer_scan_roblaser, bool &tick_scan_roblaser) {






clock x;
int u,d;

int i:= 0;
int j:= 0;
state
    start,
    manage,
    ask { x<=50 },
    count,
    decide,
    error;
commit
    count,
    decide;
init
    start;
trans
    manage -> manage { guard lock_scan_roblaser && i<size_roblaser-1; sync inter_scan_roblaser!; assign update_roblaser (finished_scan_roblaser, j, tab_roblaser),
j:= i, i:= next_roblaser (i+1, tab_roblaser, 2), turn_scan_roblaser := tab_roblaser[i]; },
    manage -> manage { guard lock_scan_roblaser && i<size_roblaser-1; sync begin_scan_roblaser!; assign update_roblaser (finished_scan_roblaser, j, tab_roblaser),
j:= i, i:= next_roblaser (i+1, tab_roblaser, 2), turn_scan_roblaser := tab_roblaser[i]; },
    manage -> start { guard lock_scan_roblaser && i == size_roblaser-1; sync exe!; assign nc++, update_roblaser (finished_scan_roblaser, j, tab_roblaser), 
i:= 0, sched_roblaser:= sched_cntrl_roblaser(tab_roblaser), 
finished_scan_roblaser:= false; },
    start -> ask { guard !(next_roblaser(i,tab_roblaser,2)==size_roblaser-1)  && tick_scan_roblaser; sync insert!; assign p[4]:= len, x:= 0, w[4]:= 25, u:= period[4], d:= 0, tick_scan_roblaser:= false; },
    ask -> error { guard x== 50; },
    ask -> count { sync up?; },
    count -> count { guard x< w[4]-1; sync cnt?; assign u:= w[4]-1, w[4]:= (u+d)/2; },
    count -> count { guard x> w[4]+1; sync cnt?; assign d:= w[4]+1, w[4]:= (u+d)/2; },
    count -> decide { guard x>= w[4] && x< w[4]+1; sync cnt?; assign rel_count++, d:=w[4], u:= 50; },
    count -> decide { guard x>= w[4]-1 && x< w[4]; sync cnt?; assign rel_count++, w[4]:= w[4]-1, d:=w[4], u:= 50; },
    count -> decide { guard x== w[4]+1; sync cnt?; assign rel_count++, w[4]:= w[4]+1, d:=w[4], u:= 50; },
    decide -> ask { guard p[4]!=-1; sync en?; },
    decide -> start { guard p[4]==-1 && next_roblaser(i,tab_roblaser,2)==size_roblaser-1; sync en?; assign p[4]:=-2, nc++, update_roblaser (finished_scan_roblaser, j, tab_roblaser), 
i:= 0, sched_roblaser:= sched_cntrl_roblaser(tab_roblaser), 
finished_scan_roblaser:= false; },
    decide -> manage { guard p[4]==-1  && !(next_roblaser(i,tab_roblaser,2)==size_roblaser-1); sync en?; assign p[4]:=-2, i:= next_roblaser (i, tab_roblaser, 2), turn_scan_roblaser := tab_roblaser[i]; };
}

process Perm_scan_roblaser(broadcast chan &end_spawn_scan_roblaser, urgent chan &exe, bool &ports[nports]) {






clock x;
state
    start_ { x<=10 },
    ether_;
init
    start_;
trans
    start_ -> ether_ { guard x>=8; sync end_spawn_scan_roblaser!; assign x:=0; };
}

process ScanMap_roblaser_(urgent chan &begin_scan_roblaser, urgent chan &inter_scan_roblaser, bool &lock_scan_roblaser,  const int instance, cell_roblaser &turn_scan_roblaser, bool &finished_scan_roblaser, urgent chan &exe, bool &ports[nports]) {






clock x;
state
    start_,
    start_2 { x<=10 },
    read_laser_ { x<=5 },
    write_lport_,
    write_lport_2 { x<=20 },
    stop_ { x<=10 },
    pause_start_,
    ether_;
init
    ether_;
trans
    ether_ -> start_ { guard turn_scan_roblaser.name == ScanMap_roblaser &&
turn_scan_roblaser.inst == instance && 
turn_scan_roblaser.status == RUN_roblaser; sync begin_scan_roblaser?; assign lock_scan_roblaser:= false, x:= 0; },
    start_ -> start_2 { guard !ports[0]; sync exe!; assign x:=0, ports[0]:= true; },
    start_2 -> read_laser_ { guard x>=8; assign x:=0, ports[0]:= false; },
    read_laser_ -> write_lport_ { guard x>=3; assign x:=0; },
    write_lport_ -> write_lport_2 { guard !ports[3]; sync exe!; assign x:=0, ports[3]:= true; },
    write_lport_2 -> pause_start_ { guard x>=18; assign lock_scan_roblaser:= true, ports[3]:= false; },
    stop_ -> ether_ { guard x==10; assign lock_scan_roblaser:= true, finished_scan_roblaser:= true; },
    pause_start_ -> start_ { guard turn_scan_roblaser.name == ScanMap_roblaser && turn_scan_roblaser.inst == instance && turn_scan_roblaser.status == RUN_roblaser; sync begin_scan_roblaser?; assign lock_scan_roblaser:= false, x:= 0; },
    pause_start_ -> stop_ { guard turn_scan_roblaser.name == ScanMap_roblaser && turn_scan_roblaser.inst == instance && turn_scan_roblaser.status == STOP_roblaser; sync inter_scan_roblaser?; assign lock_scan_roblaser:= false, x:= 0; },
    ether_ -> stop_ { guard turn_scan_roblaser.name == ScanMap_roblaser && turn_scan_roblaser.inst == instance && turn_scan_roblaser.status == STOP_roblaser; sync inter_scan_roblaser?; assign lock_scan_roblaser:= false, x:= 0; };
}

process Urgency(urgent chan &exe) {

state
    wait;
init
    wait;
trans
    wait -> wait { sync exe?; };
}

process scheduler() {

state
    start,
    update,
    give;
commit
    update,
    give;
init
    start;
trans
    start -> start { guard len< size_sched; sync insert?; assign len++; },
    start -> update { guard len>0 && nc>0; sync up!; assign rel_count:= 0; },
    update -> update { guard rel_count < len; sync cnt!; },
    update -> give { guard rel_count == len; assign update_queue(T,p,w), dequeue(T,p); },
    give -> start { sync en!; assign len--, nc--; };
}

process client() {

state
    start,
    s1,
    s2,
    s3,
    s4,
    s5,
    s6,
    s7,
    s8,
    s9,
    s10;
init
    start;
trans
    s9 -> s10 { sync end_recv_robmotion?; },
    s8 -> s9 { sync recv_robmotion!; assign req_robmotion:= GotoPosition_robmotion; },
    s7 -> s8 { sync end_recv_roblaser?; },
    s6 -> s7 { sync recv_roblaser!; assign req_roblaser:= ScanMap_roblaser; },
    s5 -> s6 { sync end_recv_robmap?; },
    s4 -> s5 { sync recv_robmap!; assign req_robmap:= FuseStart_robmap; },
    s3 -> s4 { sync end_recv_robloco?; },
    s2 -> s3 { sync recv_robloco!; assign req_robloco:= TrackSpeedStart_robloco; },
    s1 -> s2 { sync end_recv_robloco?; },
    start -> s1 { sync recv_robloco!; assign req_robloco:= TrackOdoStart_robloco; };
}






	

/* instantiations */


/* robloco */

CT_robloco:= control_robloco(recv_robloco, exe, shut_robloco, recv_urg_robloco, tab_robloco, sched_robloco, end_spawn_track_robloco, req_robloco, mutex_robloco);


timer_odo_robloco:= Timer_odo_robloco (tick_odo_robloco, shuttimer_odo_robloco); 

Man_odo_robloco:= Manager_odo_robloco (exe, lock_odo_robloco, shut_robloco, begin_odo_robloco, inter_odo_robloco, turn_odo_robloco , tab_robloco, finished_odo_robloco, sched_robloco, shuttimer_odo_robloco, tick_odo_robloco); 
	

Perm_act_odo_robloco:= Perm_odo_robloco (end_spawn_odo_robloco, exe, mutex_robloco, ports);



InitPosPort_1_robloco:= InitPosPort_robloco_ (begin_odo_robloco, inter_odo_robloco, lock_odo_robloco,
 1, turn_odo_robloco, finished_odo_robloco, exe, mutex_robloco, ports); 
 
InitPosPort_2_robloco:= InitPosPort_robloco_ (begin_odo_robloco, inter_odo_robloco, lock_odo_robloco,
 2, turn_odo_robloco, finished_odo_robloco, exe, mutex_robloco, ports); 


TrackOdoStart_1_robloco:= TrackOdoStart_robloco_ (begin_odo_robloco, inter_odo_robloco, lock_odo_robloco,
 1, turn_odo_robloco, finished_odo_robloco, exe, mutex_robloco, ports); 
 
TrackOdoStart_2_robloco:= TrackOdoStart_robloco_ (begin_odo_robloco, inter_odo_robloco, lock_odo_robloco,
 2, turn_odo_robloco, finished_odo_robloco, exe, mutex_robloco, ports); 


timer_track_robloco:= Timer_track_robloco (tick_track_robloco, shuttimer_track_robloco, end_spawn_odo_robloco); 

Man_track_robloco:= Manager_track_robloco (exe, lock_track_robloco, shut_robloco, begin_track_robloco, inter_track_robloco, turn_track_robloco , tab_robloco, finished_track_robloco, sched_robloco, shuttimer_track_robloco, tick_track_robloco); 
	

Perm_act_track_robloco:= Perm_track_robloco (end_spawn_track_robloco, end_spawn_odo_robloco, exe, mutex_robloco, ports);



TrackSpeedStart_1_robloco:= TrackSpeedStart_robloco_ (begin_track_robloco, inter_track_robloco, lock_track_robloco,
 1, turn_track_robloco, finished_track_robloco, exe, mutex_robloco, ports); 
 
TrackSpeedStart_2_robloco:= TrackSpeedStart_robloco_ (begin_track_robloco, inter_track_robloco, lock_track_robloco,
 2, turn_track_robloco, finished_track_robloco, exe, mutex_robloco, ports); 


/* robmotion */

CT_robmotion:= control_robmotion(recv_robmotion, exe, shut_robmotion, recv_urg_robmotion, tab_robmotion, sched_robmotion, end_spawn_plan_robmotion, req_robmotion);


timer_plan_robmotion:= Timer_plan_robmotion (tick_plan_robmotion, shuttimer_plan_robmotion); 

Man_plan_robmotion:= Manager_plan_robmotion (exe, lock_plan_robmotion, shut_robmotion, begin_plan_robmotion, inter_plan_robmotion, turn_plan_robmotion , tab_robmotion, finished_plan_robmotion, sched_robmotion, shuttimer_plan_robmotion, tick_plan_robmotion); 
	

Perm_act_plan_robmotion:= Perm_plan_robmotion (end_spawn_plan_robmotion, exe, ports);



GotoPosition_1_robmotion:= GotoPosition_robmotion_ (begin_plan_robmotion, inter_plan_robmotion, lock_plan_robmotion,
 1, turn_plan_robmotion, finished_plan_robmotion, exe, ports); 
 
GotoPosition_2_robmotion:= GotoPosition_robmotion_ (begin_plan_robmotion, inter_plan_robmotion, lock_plan_robmotion,
 2, turn_plan_robmotion, finished_plan_robmotion, exe, ports); 


/* robmap */

CT_robmap:= control_robmap(recv_robmap, exe, shut_robmap, recv_urg_robmap, tab_robmap, sched_robmap, end_spawn_fuse_robmap, req_robmap);


timer_fuse_robmap:= Timer_fuse_robmap (tick_fuse_robmap, shuttimer_fuse_robmap); 

Man_fuse_robmap:= Manager_fuse_robmap (exe, lock_fuse_robmap, shut_robmap, begin_fuse_robmap, inter_fuse_robmap, turn_fuse_robmap , tab_robmap, finished_fuse_robmap, sched_robmap, shuttimer_fuse_robmap, tick_fuse_robmap); 
	

Perm_act_fuse_robmap:= Perm_fuse_robmap (end_spawn_fuse_robmap, exe, ports);



FuseStart_1_robmap:= FuseStart_robmap_ (begin_fuse_robmap, inter_fuse_robmap, lock_fuse_robmap,
 1, turn_fuse_robmap, finished_fuse_robmap, exe, ports); 
 
FuseStart_2_robmap:= FuseStart_robmap_ (begin_fuse_robmap, inter_fuse_robmap, lock_fuse_robmap,
 2, turn_fuse_robmap, finished_fuse_robmap, exe, ports); 


/* roblaser */

CT_roblaser:= control_roblaser(recv_roblaser, exe, shut_roblaser, recv_urg_roblaser, tab_roblaser, sched_roblaser, end_spawn_scan_roblaser, req_roblaser);


timer_scan_roblaser:= Timer_scan_roblaser (tick_scan_roblaser, shuttimer_scan_roblaser); 

Man_scan_roblaser:= Manager_scan_roblaser (exe, lock_scan_roblaser, shut_roblaser, begin_scan_roblaser, inter_scan_roblaser, turn_scan_roblaser , tab_roblaser, finished_scan_roblaser, sched_roblaser, shuttimer_scan_roblaser, tick_scan_roblaser); 
	

Perm_act_scan_roblaser:= Perm_scan_roblaser (end_spawn_scan_roblaser, exe, ports);



ScanMap_1_roblaser:= ScanMap_roblaser_ (begin_scan_roblaser, inter_scan_roblaser, lock_scan_roblaser,
 1, turn_scan_roblaser, finished_scan_roblaser, exe, ports); 
 
ScanMap_2_roblaser:= ScanMap_roblaser_ (begin_scan_roblaser, inter_scan_roblaser, lock_scan_roblaser,
 2, turn_scan_roblaser, finished_scan_roblaser, exe, ports); 


urg:= Urgency(exe);

cl:= client();



sc:= scheduler();

system 
sc, urg, cl, CT_robloco, timer_odo_robloco, Man_odo_robloco, Perm_act_odo_robloco, InitPosPort_1_robloco, InitPosPort_2_robloco, TrackOdoStart_1_robloco, TrackOdoStart_2_robloco, timer_track_robloco, Man_track_robloco, Perm_act_track_robloco, TrackSpeedStart_1_robloco, TrackSpeedStart_2_robloco, CT_robmotion, timer_plan_robmotion, Man_plan_robmotion, Perm_act_plan_robmotion, GotoPosition_1_robmotion, GotoPosition_2_robmotion, CT_robmap, timer_fuse_robmap, Man_fuse_robmap, Perm_act_fuse_robmap, FuseStart_1_robmap, FuseStart_2_robmap, CT_roblaser, timer_scan_roblaser, Man_scan_roblaser, Perm_act_scan_roblaser, ScanMap_1_roblaser, ScanMap_2_roblaser;